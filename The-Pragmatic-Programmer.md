# The Pragmatic Programmer (20th Anniversary Edition) Notes
My thoughts and what I liked about each chapter or topic as I read them.

## Preface
Kaizen - A Japanese business philosophy of continuous improvement of working practices, personal efficiency, etc.
When asking someone what they do to make their lawn look so nice, they respond with "Every morning wipe the dew off, every other day mow the grass, and once a week roll it, and after 500 years of doing this, you too can have a nice lawn." This relates to our programming skills. If we continue to make small improvements, and continue learning new things and better ways to code, we will notice improvements much faster than a lawn. To have this "kaizen" mentality is important to getting better.

## Chapter 1. A Pragmatic Philosophy
Pragmatic Programmer - An attitude, style, or philosphy of how to approach problems and their solutions.
To be a pragmatic programmer, we need to take ownership of our projects. We should take full responsibility of it's problems, and not sit idly by knowing they exist.

### Topic 1. It's Your Life
Lots of people aren't happy in their jobs, location, or life in general. Programming is one of the easiest jobs to be able to make changes, we're paid well, and we work remotely. But programmers usually don't like change.
You have agency. Try to fix your problems but don't try forever. "You can change your organization, or you can change your organization." Investing in yourself off the clock is important. Do you want something from your current job? Have you asked? This career field provides a wide set of opportunities, be proactive and take them.

### Topic 2. The Cat Ate My Source Code
Take responsibility for your code and actions. Pragmatic programmers take charge of their own career, and aren't scared to admit to failure. Things happen. This means being honest and direct. Trusting your team is essential for creativity and collaboration. You have the right to not accept a responsibility due to possible unforseen uncontrolled events. However, if you do accept a responsibility, take ownership of what is going wrong. Provide options, don't make lame excuses. Run through the conversation in your mind before talking to your boss, how does it sound? Explain what can be done to salvage the situation. Don't be afraid to admit you need help. Flush out all lame excuses before saying them aloud. If you don't know, admit it but make sure you follow it up with "but i'll find out."

### Topic 3. Software Entropy
Entropy - Lack of order or predictability; gradual decline into disorder.
Debt and rot can spread uncontrollaby. The culture at work on a project can be a source of rot. Hopelessness can be contagious. Negative thoughts spreading through team members can be a viscious spiral. Don't leave broken windows. If you find broken code, fix it. If you can't fix the code, at least board it up. Neglect accelerates rot faster than any other factor. Don't let entropy win. Do no harm. Don't cause collateral damage because there's a crisis of some sort. One broken window is all it takes to begin the decline. A car will sit on the side of the road for weeks, but as soon as one window is broken, the car is stripped and turned upside down within hours. Don't be the first person to create broken windows in a project.

### Topic 4. Stone Soup and Boiled Frogs
Based on the stone soup story: At some point you may know exactly what to do, and how to do it. But ask for permission and you'll be met with delays and blank stares. Everyone guards their own resources. Work out what you can reasonably ask for, and talk about that. Show the importance of it, and then pretend it isn't important. Let them ask for the extra features. Show them a glimpse of the future, and people rally around an ongoing success. It's easier to ask for forgiveness than it is to get permission. Keep an eye on the big picture. Keep an eye on what's going on around you, not just your own viewpoint. Get in the habit of noticing your surroundings and do the same for your project.

### Topic 5. Good-Enough Software
You can discipline yourself to write good-enough software. Good-enough does not imply sloppy or poorly written code. Users should be able to participate in if the software is good enough for their needs. Based on the user requirements we may have strict outcomes, or a faster time table that doesn't allow us to refactor our code again. Know when to stop. Programming is like painting. All the hard work is ruined if you don't know where to stop. It can never be perfect.

### Topic 6. Your Knowledge Portfolio
Your knowledge and experience are the most important day to day professional assets. However, they're expiring assets. As the value of your knowledge declines, so does it to your company or your client. We don't want this to happen. Invest regularly in your knowledge. Make yourself do it at first and form the habit, and eventually you'll be learning new things continually. You should know the ins and outs of what you're working on now. But don't stop there, as the tech field is fast moving and there is always something new. Learn brand new technologies before they're popular. Learn at least one new language every year. Read a technical book each month. Isolation can be deadly to your career. Find out what people are working on outside your company. Plan ahead, always have something to read in a dead moment as time is hard to come by. Think critically about what you read and hear. Ask the five whys. Ask why five times. "Best practice" - best for who?

### Topic 7. Communicate!
Treat english as just another programming language. Apply the same princicples such as DRY and ETC, as discussed in the next chapter. The meaning of your communication is the response you get. Know what you want to say. Plan what you want to say, write an outline. You need to know what priorities there are, what you say should be relevant in time and importance. There is no excuse to producing poor looking documents. Use stylesheets for consistency. If possible get your readers to see the drafts of the documents and get their opinion. Get back with people, always respond to emails and voicemails even if the response is "I will get back to you later." Pragmatic programmers view documentation as an integral part of the development process. Every function does not need its own comment, it actually makes it more difficult. Proof-read before you hit send. Correct your spelling and look for auto-correct mishaps. Give the same attention and care to an email as you would to any written report.

## Chapter 2. A Pragmatic Approach
There are topics that apply to all kinds of software. Those are the following:

### Topic 8. The Essence of Good Design
Good design is easier to change than bad design. It is well designed if it easily adapts by those who use it. ETC - easier to change. ETC is a value, not a rule. It will help you make decisions. Ask yourself, "Did the thing I just did make it easier or harder to change in the future?" To do this effectively, you need to develop instincts on how to write your code. You could easily fall into a practice of making code easier to change but never actually writing new code. Practicing is key. Documenting what you changed and why is a good way to track your progress and learn from your past mistakes.

### Topic 9. DRY - The Evils of Duplication
Most of our time is spent in maintenance mode. Our understanding changes every day. When duplicating code in our projects, we are creating a maintenance nightmare. DRY - don't repeat yourself. When there is a duplication and you need to change something in the code, it's not a matter of if you'll remember to change the others, it's a matter of when you'll forget. Dry is about the duplication of knowledge and intent. Acid test - when one single facet of the code has to change, do you find yourself changing things in multiple places and in multiple formats? If so, your code is not DRY. Someone may have written a function that validates if someone's age is greater than 0, and a seperate function that validates the order quantity ensuring that it also is greater than 0. Someone might see this and think it's a DRY violation, but it isn't. They are two separate pieces of knowledge. The validation being the same for both pieces of knowledge is just a coincidence. Some believe you need to comment logic on each function you build. This is not the case. Your naming and function logic should be as clear as a comment. Ask yourself, "What does this comment add to the clarity of the function?"

### Topic 10. Orthogonality
Orthogonality - borrowed from geometry, the term signifies an independence or decoupling. Two or more things are orthogonal if changes in one doesn't affect the others. Good orthogonality can be a backend and frontend. You should be able to change the database without changing the user interface, and vise versa. Non-orthogonal sytems are much harder to change and control. Orthogonality can be used by our design. Developers already put this into practice but use terms like "modular", "component-based", and "layered". Systems should be composed of a set of modules that you can easily change independently. Be careful about using libraries and toolkits, make sure they don't change any processes of current code. Write shy code. Avoid global data. Get in the habit of being constantly critical of your code and always be improving it - this process is called refactoring. If orthogonality and DRY principles are followed in tandem, you will find that the systems you develop are more flexible, more understandable, and more easier to test and maintain. If you find that when you change a single piece of code, and you notice other things start breaking as a result, remember the system is not orthogonal - it is time to refactor.

### Topic 11. Reversibility
Nothing is forever. If you rely heavily on a fact you can almost guarantee it will change. Mistakes lie where we assume any decisions are set in stone, instead imagine they are words written in the sand at the beach. There are no concrete decisions. You should be able to swap out databases with ease, or easily adjust your server to run a mobile app rather than a web app. Forgo following fads. Nobody knows what the future holds, especially us in the tech world.

### Topic 12. Tracer Bullets
Tracer bullets are loaded in intervals among regular ammunition. If the tracers are hitting the targets, then so is their regular bullets. Like the gunners, we're trying to hit targets in the dark. We face a large number of unknowns. We can guarantee the envorinment in which we're working in to change before we're done. Pragmatic programmers should use code that glows in the dark. Look for important requirements, the ones that define the system. Prioritize these requirements to focus in on. Tracer development is an incremental approach, a project is never finished. Users get to see something working early. If you communicate correctly they will know they are seeing something immature, something that is just starting and they will be excited to see progress. This also allows them to contribute and help along the way. This is in contrast to "big bang" programming. You have better feel for progress. Each iteration feels like a large step forward. Sometimes our tracer bullets don't hit the target, but that's ok. That's the point. Use the tracers to take better aim at it next time, and because you've written easy to change code, refactoring won't be catastrophic. You might use a pre-built UI, get it approved, and then delete everything to integrate the required business rules in your code. That prebuilt UI is a tracer bullet.

### Topic 13. Prototypes and Post-it Notes
Prototypes speed up production. We make prototypes to analyze strengths and weaknesses. We usually think of prototypes created from code, but there are many different prototypes we can make depending on the project. Prototypes will work in a very limited sense to demonstrate or test what the goal is if you were to build it. Ask yourself if you're building a prototype or if you're building the project, if you're building the prototype begin building using the tracer bullets method. When we have a prototype we can ask questions to see if it stacks up to our requirements. Make sure others know that a prototype is disposable code. If you believe the thinking process to the use of your prototype will be confused, build with the tracer bullet method rather than building a prototype.

### Topic 14. Domain Languages
Not going to lie, this topic went right over my head. Hopefully next time I read this book I'll have something to note here.

### Topic 15. Estimating
Estimate to avoid surprises. All answers are estimates, but some are more accurate than others. Are they looking for accuracy, or a rough ball park answer? If you feel your work can get done in 2 weeks, quote it in days. 3-6 weeks, quote it in weeks. 8-20 weeks, quote it in months. If you think it will take more than 20 weeks, think hard before giving an estimate. All estimates are based on models of the problem. A good way to know a good estimate, ask someone who has already done it. Understand what is being asked. "Assuming there is gas in the tank and no traffic on the way, I should be there in 20 minutes." Record your estimates and see how close you were. Often you'll find that your estimates were pretty good, and you'll begin to expect this. If you're wrong take some time to think about what you forgot about or what went wrong, and use it to improve on your future estimates. Give a range of scenarios, a best case, a likely scenario, and a worst case scenario. 
