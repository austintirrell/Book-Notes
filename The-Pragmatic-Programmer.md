# The Pragmatic Programmer (20th Anniversary Edition) Notes
My thoughts and what I liked about each chapter or topic as I read them.

## Table of Contents
Will add chapters as I read them...

[Chapter 1. A Pragmatic Philosophy](#chapter-1-a-pragmatic-philosophy)  
[Chapter 2. A Pragmatic Approach](#chapter-2-a-pragmatic-approach)  
[Chapter 3. The Basic Tools](#chapter-3-the-basic-tools)
[Chapter 4. Pragmatic Paranoia](#chapter-4-pragmatic-paranoia)
[Chapter 5. Bend, or Break](#chapter-5-bend-or-break)
[Chapter 6. Concurrency](#chapter-6-concurrency)

## Preface
Kaizen - A Japanese business philosophy of continuous improvement of working practices, personal efficiency, etc.
When asking someone what they do to make their lawn look so nice, they respond with "Every morning wipe the dew off, every other day mow the grass, and once a week roll it, and after 500 years of doing this, you too can have a nice lawn." This relates to our programming skills. If we continue to make small improvements, and continue learning new things and better ways to code, we will notice improvements much faster than a lawn. To have this "kaizen" mentality is important to getting better.

## Chapter 1. A Pragmatic Philosophy
Pragmatic Programmer - An attitude, style, or philosphy of how to approach problems and their solutions.
To be a pragmatic programmer, we need to take ownership of our projects. We should take full responsibility of it's problems, and not sit idly by knowing they exist.

### Topic 1. It's Your Life
Lots of people aren't happy in their jobs, location, or life in general. Programming is one of the easiest jobs to be able to make changes, we're paid well, and we work remotely. But programmers usually don't like change.
You have agency. Try to fix your problems but don't try forever. "You can change your organization, or you can change your organization." Investing in yourself off the clock is important. Do you want something from your current job? Have you asked? This career field provides a wide set of opportunities, be proactive and take them.

### Topic 2. The Cat Ate My Source Code
Take responsibility for your code and actions. Pragmatic programmers take charge of their own career, and aren't scared to admit to failure. Things happen. This means being honest and direct. Trusting your team is essential for creativity and collaboration. You have the right to not accept a responsibility due to possible unforseen uncontrolled events. However, if you do accept a responsibility, take ownership of what is going wrong. Provide options, don't make lame excuses. Run through the conversation in your mind before talking to your boss, how does it sound? Explain what can be done to salvage the situation. Don't be afraid to admit you need help. Flush out all lame excuses before saying them aloud. If you don't know, admit it but make sure you follow it up with "but i'll find out."

### Topic 3. Software Entropy
Entropy - Lack of order or predictability; gradual decline into disorder.
Debt and rot can spread uncontrollaby. The culture at work on a project can be a source of rot. Hopelessness can be contagious. Negative thoughts spreading through team members can be a viscious spiral. Don't leave broken windows. If you find broken code, fix it. If you can't fix the code, at least board it up. Neglect accelerates rot faster than any other factor. Don't let entropy win. Do no harm. Don't cause collateral damage because there's a crisis of some sort. One broken window is all it takes to begin the decline. A car will sit on the side of the road for weeks, but as soon as one window is broken, the car is stripped and turned upside down within hours. Don't be the first person to create broken windows in a project.

### Topic 4. Stone Soup and Boiled Frogs
Based on the stone soup story: At some point you may know exactly what to do, and how to do it. But ask for permission and you'll be met with delays and blank stares. Everyone guards their own resources. Work out what you can reasonably ask for, and talk about that. Show the importance of it, and then pretend it isn't important. Let them ask for the extra features. Show them a glimpse of the future, and people rally around an ongoing success. It's easier to ask for forgiveness than it is to get permission. Keep an eye on the big picture. Keep an eye on what's going on around you, not just your own viewpoint. Get in the habit of noticing your surroundings and do the same for your project.

### Topic 5. Good-Enough Software
You can discipline yourself to write good-enough software. Good-enough does not imply sloppy or poorly written code. Users should be able to participate in if the software is good enough for their needs. Based on the user requirements we may have strict outcomes, or a faster time table that doesn't allow us to refactor our code again. Know when to stop. Programming is like painting. All the hard work is ruined if you don't know where to stop. It can never be perfect.

### Topic 6. Your Knowledge Portfolio
Your knowledge and experience are the most important day to day professional assets. However, they're expiring assets. As the value of your knowledge declines, so does it to your company or your client. We don't want this to happen. Invest regularly in your knowledge. Make yourself do it at first and form the habit, and eventually you'll be learning new things continually. You should know the ins and outs of what you're working on now. But don't stop there, as the tech field is fast moving and there is always something new. Learn brand new technologies before they're popular. Learn at least one new language every year. Read a technical book each month. Isolation can be deadly to your career. Find out what people are working on outside your company. Plan ahead, always have something to read in a dead moment as time is hard to come by. Think critically about what you read and hear. Ask the five whys. Ask why five times. "Best practice" - best for who?

### Topic 7. Communicate!
Treat english as just another programming language. Apply the same princicples such as DRY and ETC, as discussed in the next chapter. The meaning of your communication is the response you get. Know what you want to say. Plan what you want to say, write an outline. You need to know what priorities there are, what you say should be relevant in time and importance. There is no excuse to producing poor looking documents. Use stylesheets for consistency. If possible get your readers to see the drafts of the documents and get their opinion. Get back with people, always respond to emails and voicemails even if the response is "I will get back to you later." Pragmatic programmers view documentation as an integral part of the development process. Every function does not need its own comment, it actually makes it more difficult. Proof-read before you hit send. Correct your spelling and look for auto-correct mishaps. Give the same attention and care to an email as you would to any written report.

## Chapter 2. A Pragmatic Approach
There are topics that apply to all kinds of software. Those are the following:

### Topic 8. The Essence of Good Design
Good design is easier to change than bad design. It is well designed if it easily adapts by those who use it. ETC - easier to change. ETC is a value, not a rule. It will help you make decisions. Ask yourself, "Did the thing I just did make it easier or harder to change in the future?" To do this effectively, you need to develop instincts on how to write your code. You could easily fall into a practice of making code easier to change but never actually writing new code. Practicing is key. Documenting what you changed and why is a good way to track your progress and learn from your past mistakes.

### Topic 9. DRY - The Evils of Duplication
Most of our time is spent in maintenance mode. Our understanding changes every day. When duplicating code in our projects, we are creating a maintenance nightmare. DRY - don't repeat yourself. When there is a duplication and you need to change something in the code, it's not a matter of if you'll remember to change the others, it's a matter of when you'll forget. Dry is about the duplication of knowledge and intent. Acid test - when one single facet of the code has to change, do you find yourself changing things in multiple places and in multiple formats? If so, your code is not DRY. Someone may have written a function that validates if someone's age is greater than 0, and a seperate function that validates the order quantity ensuring that it also is greater than 0. Someone might see this and think it's a DRY violation, but it isn't. They are two separate pieces of knowledge. The validation being the same for both pieces of knowledge is just a coincidence. Some believe you need to comment logic on each function you build. This is not the case. Your naming and function logic should be as clear as a comment. Ask yourself, "What does this comment add to the clarity of the function?"

### Topic 10. Orthogonality
Orthogonality - borrowed from geometry, the term signifies an independence or decoupling. Two or more things are orthogonal if changes in one doesn't affect the others. Good orthogonality can be a backend and frontend. You should be able to change the database without changing the user interface, and vise versa. Non-orthogonal sytems are much harder to change and control. Orthogonality can be used by our design. Developers already put this into practice but use terms like "modular", "component-based", and "layered". Systems should be composed of a set of modules that you can easily change independently. Be careful about using libraries and toolkits, make sure they don't change any processes of current code. Write shy code. Avoid global data. Get in the habit of being constantly critical of your code and always be improving it - this process is called refactoring. If orthogonality and DRY principles are followed in tandem, you will find that the systems you develop are more flexible, more understandable, and more easier to test and maintain. If you find that when you change a single piece of code, and you notice other things start breaking as a result, remember the system is not orthogonal - it is time to refactor.

### Topic 11. Reversibility
Nothing is forever. If you rely heavily on a fact you can almost guarantee it will change. Mistakes lie where we assume any decisions are set in stone, instead imagine they are words written in the sand at the beach. There are no concrete decisions. You should be able to swap out databases with ease, or easily adjust your server to run a mobile app rather than a web app. Forgo following fads. Nobody knows what the future holds, especially us in the tech world.

### Topic 12. Tracer Bullets
Tracer bullets are loaded in intervals among regular ammunition. If the tracers are hitting the targets, then so is their regular bullets. Like the gunners, we're trying to hit targets in the dark. We face a large number of unknowns. We can guarantee the envorinment in which we're working in to change before we're done. Pragmatic programmers should use code that glows in the dark. Look for important requirements, the ones that define the system. Prioritize these requirements to focus in on. Tracer development is an incremental approach, a project is never finished. Users get to see something working early. If you communicate correctly they will know they are seeing something immature, something that is just starting and they will be excited to see progress. This also allows them to contribute and help along the way. This is in contrast to "big bang" programming. You have better feel for progress. Each iteration feels like a large step forward. Sometimes our tracer bullets don't hit the target, but that's ok. That's the point. Use the tracers to take better aim at it next time, and because you've written easy to change code, refactoring won't be catastrophic. You might use a pre-built UI, get it approved, and then delete everything to integrate the required business rules in your code. That prebuilt UI is a tracer bullet.

### Topic 13. Prototypes and Post-it Notes
Prototypes speed up production. We make prototypes to analyze strengths and weaknesses. We usually think of prototypes created from code, but there are many different prototypes we can make depending on the project. Prototypes will work in a very limited sense to demonstrate or test what the goal is if you were to build it. Ask yourself if you're building a prototype or if you're building the project, if you're building the prototype begin building using the tracer bullets method. When we have a prototype we can ask questions to see if it stacks up to our requirements. Make sure others know that a prototype is disposable code. If you believe the thinking process to the use of your prototype will be confused, build with the tracer bullet method rather than building a prototype.

### Topic 14. Domain Languages
Not going to lie, this topic went right over my head. Hopefully next time I read this book I'll have something to note here.

### Topic 15. Estimating
Estimate to avoid surprises. All answers are estimates, but some are more accurate than others. Are they looking for accuracy, or a rough ball park answer? If you feel your work can get done in 2 weeks, quote it in days. 3-6 weeks, quote it in weeks. 8-20 weeks, quote it in months. If you think it will take more than 20 weeks, think hard before giving an estimate. All estimates are based on models of the problem. A good way to know a good estimate, ask someone who has already done it. Understand what is being asked. "Assuming there is gas in the tank and no traffic on the way, I should be there in 20 minutes." Record your estimates and see how close you were. Often you'll find that your estimates were pretty good, and you'll begin to expect this. If you're wrong take some time to think about what you forgot about or what went wrong, and use it to improve on your future estimates. Give a range of scenarios, a best case, a likely scenario, and a worst case scenario. 

## Chapter 3. The Basic Tools
Every worker starts their journey with a good set of basic tools. Then each worker learns more. Each tool needs handled or worn a certain way. These tools have become extensions to the worker's hands. As you have more experience and knowledge you will slowly add to your set of tools. Always be looking for better ways to do things. This chapter is about exploring our basic tools and finding better ways to do things.

### Topic 16. The Power of Plain Text
Plain text is made up of principle characters that conveys information. Could be a shopping list, or anything else. Keep knowledge in plain text. Human readable is different than human understandable. Just about everything operates on plain text.

### Topic 17. Shell Games
The workbench of a programmer is the shell terminal. If you do all your work on GUIs you miss a lot of power in your environment. You can't set automations or macros for things you do regularly. GUIs are limited by the people that made them, and often you need to go beyond the limits. Gain familiarity with the shell. It might look daunting to begin with but spend some time on it and things will start falling into place. We need to customize our shell. Adding aliases for things that we forget. Add command finishing functionality. We spend a lot of time in our shells so make it our home.

### Topic 18. Power Editing
We need to achieve editor fluency. You might gain a whole week a year by optimizing how you edit code. Comment and uncomment lines of code with a single command. Search for strings and regexp. Can we do all of this and more with a mouse or trackpad? If we can't maybe its time to switch editors. Everytime we find ourselves doing something repetitive, think "there must be a better way." Then find the better way and commit it to memory. Dig into your editor's extension language if you can't find the fix. Turn off auto delete, but instead figure out how to select a portion of text and delete it with only your keyboard. Spend a week not touching your mouse and if there's something you can't do, now is your time to learn it. You'll take a productivity hit for a while, but once you're fluent in your editor you will see you are far more efficient than previously.

### Topic 19. Version Control
Those that can't remember the past are condemned to repeat it. Version control systems are giant undo keys. Shared directories are not version control. Version control systems keep track of every minute change in your code. You will be able to see the difference between last week and this week, who changed it, and how many lines of code were added and deleted. Always use version control. Even if its a throw-away project. Maybe you aren't writing source code, still use version control. The text of this book was written with a version control system. Branches are a huge benefit of a version control system. Branches are like small clones of the project, that doesn't interfere or make changes to your team's branches or the main branch until you merge it to the main branch. Many teams have a deployment automation that when changes are merged to the main branch, it automatically runs the tests, validates the source code, and deploys it live. Seems scary, but we have version control - we can just roll it back if it fails. Do you know all of the commands to do these things? Learn these now before it's an emergency.

### Topic 20. Debugging
The word bug has been used to describe an object of terror since the 14th century. The inventor of Cobal is credited to find the first computer bug - literally. A moth had found its way into the computer. Computer systems are limited to what we tell them to do, not what we want them to do. Embrace the fact that debugging is just problem solving. Instead of blaming the person that caused the bug, work on the problem. Fix the problem, not the blame. Turn off your ego when debugging. Don't panic. Step back, and actually think about what would cause the symptoms of the bug. Don't waste a single neuron on the thought of "that can't happen", because clearly it can - and has. Resist the urge to fix just the symptoms you see. It may involve a number of other related things. Find the root cause of the problem, not this particular appearance of it. Make sure we write code cleanly - without warnings. Set your linter to the highest settings. Fail a test before fixing code. Look at the problem - is it a crash? Read the error message. What if it's not a crash, what if it's just a bad result? Sometimes the problem is obvious. More often, we have to look deeper to find the true problem. Read the call stack. "Binary chop" is a method or algorithm that allows you to find the data you need in a very efficient way. You cut the data in half, check the highest number in first half and if smaller than our search value, take the second half. Continue cutting the data in half until you find the value you're looking for. We can apply this algorithm to debugging the call stack. Cut the callstack down the middle and see if the bug manifests itself there, if it is you know to focus on the frames before. If not you know to focus on the frames after. At most this will take you 6 attempts to find the bug. Print statements are effective at debugging where debuggers can't. These are called tracer statements. A very simple but effective technique to debug is rubber ducking... Explain every step of the code out loud to a person or thing. By having to verbalize each step, you might realize something that you would've taken for granted going through your code alone. The amount of disbelief when a bug occurs is the amount of trust you put into the code you've written.

### Topic 21. Text Manipulation
Pragmatic programmers manipulate text the same way woodworkers manipulate wood. We need to handle transformations that can't be handled by the basic tools we already know and use. Learn a text manipulation language - like Python. Use these languages to automate things. If we take the advice to keep things in plain text, using these text manipulation languages to write scripts will bring a whole host of benefits. Automations used to index this book and upload sample PDFs are keen examples of what this can do.

### Topic 22. Engineering Daybooks
A daybook is a journal in which they recorded everything they did. Stuff they learned, ideas, sketches. When the book got full, they would write the date and stick it on the shelf. Jot down what you're working on. While you're debugging write down stack calls. When needing to remember to come back to something, write it down. It gives you a place to store ideas that isn't immediately relevant to the task at hand. It acts as a kind of rubber duck, for us to explain something we're working on and see the issue. We can use daybooks as a memory to look back on as well.

## Chapter 4. Pragmatic Paranoia
You can't write perfect software. Accept it. Embrace it. Perfect software doesn't exist. If we don't accept that as fact, we'll waste time chasing an unattainable dream. When we drive a car, we drive defensively. We are looking out for other bad drivers. The same goes for code we work on. We should code defensively. But not only do we look out for other's mistakes, we look out for our own.

### Topic 23. Design by Contract
Dealing with computer systems is hard, but dealing with people is harder. Contracts are used to help humans interact. Can we use this thinking in our programming? Yes. Create a program that does no more, and no less than what its purpose is. This is how we design by contract. Failure to live up to the contract is a bug. This should never happen.

### Topic 24. Dead Programs Tell No Lies
Other people can tell something is wrong with you before you notice it yourself. Same goes for our code. Sometimes a library or module catches the error first. Each and every case or switch statement needs to have a default clause. We need to know when the impossible happens. We're coding defensively. We're making sure the code is what we think it is and that the output is what we think it is. You could convince yourself that the error was a fluke and that it was impossible, but pragmatic programmers recognize that something bad happened. Crash early. One of the best things we can do when something unaccounted for is to crash early. That way we aren't writing or using corrupt data. When your code discovers that something impossible just happened, it should crash. A dead program does less damage than a crippled one.

### Topic 25. Assertive Programming
Use assertions to prevent the impossible. Whenever you catch yourself thinking "that can never happen", add assertions to make sure it doesn't happen. Don't place assertions in place of real error handling. Assertions to catch errors can actually cause errors. Leave assertions turned on. Assertions are not an overhead in the code, and we shouldn't remove assertions in production because it slows the program down. Turning off assertions in production is like taking away the giant net just because you've walked across the high wire once and didn't fall.

### Topic 26. How to Balance Resources
We all manage resources whenever we code. All kinds of things that have limited availability. We usually allocate resources, use it, then deallocate it. Finish what you start. The function or object that allocates a resource should be responsible for deallocating it. Act locally. Deallocate resources in the opposite order of which you allocate them. When allocating the same set of resources, always allocate them in the same order. In some languages, we can develop this further. Object oriented languages using classes and constructors can help with doing this automatically.

### Topic 27. Donâ€™t Outrun Your Headlights
The drivers ability to stop or steer in time of the headlight illumination. Headlights only project so far, and only in a straight line - not left or right. In software development we can't see too far into the future, so pragmatic programmers have a rule, take small steps. Check for feedback and adjust before proceeding. Any task that requires fortune telling, is too big of a task. Aren't we supposed to design for future maintenance? Yes, but only as far as you can see. The further you try to see into the future, the better the chance of you being wrong. Avoid fortune telling. Most of the time, tomorrow looks a lot like today. But don't count on it.

## Chapter 5. Bend, or Break
Our code doesn't stand still. In order to keep up with change, we need to make every effort to write loose and flexible code as possible, otherwise our code will be too hard to fix. This chapter will tell us how to make reversible decisions, so our code can be adaptable in an always changing world. Decoupling will allow us to break up code for different purposes. Will talk about strategies on how to manage and react to events. A good way to stay flexible is to write less code. Changing code adds the chance for there to be a bug. All of these things will help us write code that bends, and that doesn't break.

### Topic 28. Decoupling
Decoupling refers to the dependencies between different parts of your code, making it more modular, flexible, and maintainable. To accomplish this we need to write "shy" code. Writing modules of code that doesn't reveal its inner workings to other parts of the software unnecessarily. We can also use DTOs that carry data between processes, that promote loose coupling. Or, we can employ message queues or event systems to communicate between different parts of the software. This allows for the decoupling of components and allows for better scalability, easier to change, and isolates code. Decoupling is needed because we don't want to break the whole system based on one small change. Individual components can be understood, worked on, and tested in isolation, and enhances code reusability.

### Topic 29. Juggling the Real World
Computers at one point in time were not flexible and we had to work around them. But today we want and need them to be flexible and work around us. However there are real-world constraints in programming. We need to expect the unexpected. We must be prepared for external systems or libraries to act unpredictably or fail. We also need to design our system to handle failure gracefully, by providing meaningful feedback to the user and attempting to preserve functionality. We can do this with transactions. Transactions are used to ensure that operations in our software are completed successfully or rolled back entirely, so that we maintain integrity in our software.

### Topic 30. Transforming Programming
We need to think of our software as transforming data from one form into another. It's about recognizing that at the heart of most programming tasks is a transformation process, whether it's processing user input, generating reports, or communicating with other systems. To help us think about our software as transforming an input into an output, we need to have a clear understanding of what our program needs to do. The better we understand the data coming in and how we want the data to go out, the better we can design the inner workings to do just that and allowing for the most flexibility as possible. Thinking about it in this way helps us to build data driven applications. Transformations should be the core of our design, making it crucial to understand what data we have, what we need to do with it, and what it should look like after the transformation. To help us transform data, we can think about organizing our code in layers, where each layer is responsible for a specific transformation of the data. This layered approach can help us to manage the complexity of our software and make systems that are easier to understand and maintain.

### Topic 31. Inheritance Tax
In object-oriented programming, there is cost and limitations associated with using inheritance. We can run into complexity and maintenance challenges that arise when inheritance is used improperly or excessively. Inheritance often leads to tight coupling of code. This happens between parent and child classes. This makes our software more rigid and less modular, as changes in the parent class can have a big effect on everything that uses that inherits that class. We need to consider whether or not using inheritance is worth it in our code, or even is the most appropriate method to use. If we need to use inheritance, we should do so with good judgement. To get around using class inheritance, we can use composition. Composition involves assembling functionality by combining smaller, and simpler objects rather than inheriting from a base class. Composition allows our code to be more flexible and reusable due to the smaller component aspect, and this reduces dependencies between components.

### Topic 32. Configuration
We can use configuration outside of our code, to allow it to be more flexible and easier to change. We want the configuration to be external, so that we don't have to modify, recompile, or redeploy our applications. To externalize our configuration we can use config files, databases, or environment variables. Environment variables are typically used for sensitive information like API keys or other credentials. We want to use environment variables because they are easy to change between environments, and shouldn't be checked into source control like git, to not expose sensitive data. If we have environments that have many different configurations and will be changing and updating a lot, we can look into configuration management tools that can help manage our configuration settings across multiple environments.

## Chapter 6. Concurrency
Concurrency is when two or more pieces of code act as if they run at the same time. Parallelism is when they do run at the same time. Concurrency is achieved with threading. Parallelism is achieved with multiple cores in a CPU, multiple CPUs, or multiple computers tied together. To build modern software to account for the real world where things are done asynchronous, we need concurrency. Otherwise, our software will feel sluggish. Temporal coupling is when your code depends on things that are not needed to be done, in order to solve the problem at hand. Shared state is when two or more chunks of code hold references to the same piece of data, and is error prone. Concurrent and parallel code used to be exotic, but now it is required.

### Topic 33. Breaking Temporal Coupling
Temporal coupling is all about time. There are two important aspects to time that we need to be concerned about, concurrency and ordering. When designing softare, we tend to always think linear. Tick must happen before tock. This approach is not flexible, and not realistic. To better design our software we need to think about what can happen at the same time and what must happen in strict order. To better design concurrent software we can use activity diagrams. When designing for concurrency we are looking for activities that take time, but not time in our code. Concurrency is a software mechanism, and parallelism is a hardware concern.

### Topic 34. Shared State Is Incorrect State
You have a joint bank account. You and your partner both try buying a new phone at the same time, but there's only enough in the account to purchase one. Someone, either the bank account, the store, or you, is going to be unhappy. This is shared state. The problem is not that the two processes can change that state, but that its memory of that state is consistent. The solution to this problem is a semaphore. A semaphore states that you and only you are going to access the bank account and once you complete your purchase, you then unlock the semaphore and allow for more purchases to be made once the transaction is complete. If two purchases were made at the same time, either you or your partner's transaction would get the semaphore, and the other would be forced to wait. Once the semaphore is released from the other, then the other transaction can then take a look at the account balance and see there is not enough money left and the transaction is declined. We can make the semaphore a core mechanic of the bank itself, and not relying on the cardholders.