# The Pragmatic Programmer (20th Anniversary Edition) Notes
My thoughts and what I liked about each chapter or topic as I read them.

## Table of Contents
Will add chapters as I read them...

[Chapter 1. A Pragmatic Philosophy](#chapter-1-a-pragmatic-philosophy)  
[Chapter 2. A Pragmatic Approach](#chapter-2-a-pragmatic-approach)  
[Chapter 3: The Basic Tools](#chapter-3-the-basic-tools)

## Preface
Kaizen - A Japanese business philosophy of continuous improvement of working practices, personal efficiency, etc.
When asking someone what they do to make their lawn look so nice, they respond with "Every morning wipe the dew off, every other day mow the grass, and once a week roll it, and after 500 years of doing this, you too can have a nice lawn." This relates to our programming skills. If we continue to make small improvements, and continue learning new things and better ways to code, we will notice improvements much faster than a lawn. To have this "kaizen" mentality is important to getting better.

## Chapter 1. A Pragmatic Philosophy
Pragmatic Programmer - An attitude, style, or philosphy of how to approach problems and their solutions.
To be a pragmatic programmer, we need to take ownership of our projects. We should take full responsibility of it's problems, and not sit idly by knowing they exist.

### Topic 1. It's Your Life
Lots of people aren't happy in their jobs, location, or life in general. Programming is one of the easiest jobs to be able to make changes, we're paid well, and we work remotely. But programmers usually don't like change.
You have agency. Try to fix your problems but don't try forever. "You can change your organization, or you can change your organization." Investing in yourself off the clock is important. Do you want something from your current job? Have you asked? This career field provides a wide set of opportunities, be proactive and take them.

### Topic 2. The Cat Ate My Source Code
Take responsibility for your code and actions. Pragmatic programmers take charge of their own career, and aren't scared to admit to failure. Things happen. This means being honest and direct. Trusting your team is essential for creativity and collaboration. You have the right to not accept a responsibility due to possible unforseen uncontrolled events. However, if you do accept a responsibility, take ownership of what is going wrong. Provide options, don't make lame excuses. Run through the conversation in your mind before talking to your boss, how does it sound? Explain what can be done to salvage the situation. Don't be afraid to admit you need help. Flush out all lame excuses before saying them aloud. If you don't know, admit it but make sure you follow it up with "but i'll find out."

### Topic 3. Software Entropy
Entropy - Lack of order or predictability; gradual decline into disorder.
Debt and rot can spread uncontrollaby. The culture at work on a project can be a source of rot. Hopelessness can be contagious. Negative thoughts spreading through team members can be a viscious spiral. Don't leave broken windows. If you find broken code, fix it. If you can't fix the code, at least board it up. Neglect accelerates rot faster than any other factor. Don't let entropy win. Do no harm. Don't cause collateral damage because there's a crisis of some sort. One broken window is all it takes to begin the decline. A car will sit on the side of the road for weeks, but as soon as one window is broken, the car is stripped and turned upside down within hours. Don't be the first person to create broken windows in a project.

### Topic 4. Stone Soup and Boiled Frogs
Based on the stone soup story: At some point you may know exactly what to do, and how to do it. But ask for permission and you'll be met with delays and blank stares. Everyone guards their own resources. Work out what you can reasonably ask for, and talk about that. Show the importance of it, and then pretend it isn't important. Let them ask for the extra features. Show them a glimpse of the future, and people rally around an ongoing success. It's easier to ask for forgiveness than it is to get permission. Keep an eye on the big picture. Keep an eye on what's going on around you, not just your own viewpoint. Get in the habit of noticing your surroundings and do the same for your project.

### Topic 5. Good-Enough Software
You can discipline yourself to write good-enough software. Good-enough does not imply sloppy or poorly written code. Users should be able to participate in if the software is good enough for their needs. Based on the user requirements we may have strict outcomes, or a faster time table that doesn't allow us to refactor our code again. Know when to stop. Programming is like painting. All the hard work is ruined if you don't know where to stop. It can never be perfect.

### Topic 6. Your Knowledge Portfolio
Your knowledge and experience are the most important day to day professional assets. However, they're expiring assets. As the value of your knowledge declines, so does it to your company or your client. We don't want this to happen. Invest regularly in your knowledge. Make yourself do it at first and form the habit, and eventually you'll be learning new things continually. You should know the ins and outs of what you're working on now. But don't stop there, as the tech field is fast moving and there is always something new. Learn brand new technologies before they're popular. Learn at least one new language every year. Read a technical book each month. Isolation can be deadly to your career. Find out what people are working on outside your company. Plan ahead, always have something to read in a dead moment as time is hard to come by. Think critically about what you read and hear. Ask the five whys. Ask why five times. "Best practice" - best for who?

### Topic 7. Communicate!
Treat english as just another programming language. Apply the same princicples such as DRY and ETC, as discussed in the next chapter. The meaning of your communication is the response you get. Know what you want to say. Plan what you want to say, write an outline. You need to know what priorities there are, what you say should be relevant in time and importance. There is no excuse to producing poor looking documents. Use stylesheets for consistency. If possible get your readers to see the drafts of the documents and get their opinion. Get back with people, always respond to emails and voicemails even if the response is "I will get back to you later." Pragmatic programmers view documentation as an integral part of the development process. Every function does not need its own comment, it actually makes it more difficult. Proof-read before you hit send. Correct your spelling and look for auto-correct mishaps. Give the same attention and care to an email as you would to any written report.

## Chapter 2. A Pragmatic Approach
There are topics that apply to all kinds of software. Those are the following:

### Topic 8. The Essence of Good Design
Good design is easier to change than bad design. It is well designed if it easily adapts by those who use it. ETC - easier to change. ETC is a value, not a rule. It will help you make decisions. Ask yourself, "Did the thing I just did make it easier or harder to change in the future?" To do this effectively, you need to develop instincts on how to write your code. You could easily fall into a practice of making code easier to change but never actually writing new code. Practicing is key. Documenting what you changed and why is a good way to track your progress and learn from your past mistakes.

### Topic 9. DRY - The Evils of Duplication
Most of our time is spent in maintenance mode. Our understanding changes every day. When duplicating code in our projects, we are creating a maintenance nightmare. DRY - don't repeat yourself. When there is a duplication and you need to change something in the code, it's not a matter of if you'll remember to change the others, it's a matter of when you'll forget. Dry is about the duplication of knowledge and intent. Acid test - when one single facet of the code has to change, do you find yourself changing things in multiple places and in multiple formats? If so, your code is not DRY. Someone may have written a function that validates if someone's age is greater than 0, and a seperate function that validates the order quantity ensuring that it also is greater than 0. Someone might see this and think it's a DRY violation, but it isn't. They are two separate pieces of knowledge. The validation being the same for both pieces of knowledge is just a coincidence. Some believe you need to comment logic on each function you build. This is not the case. Your naming and function logic should be as clear as a comment. Ask yourself, "What does this comment add to the clarity of the function?"

### Topic 10. Orthogonality
Orthogonality - borrowed from geometry, the term signifies an independence or decoupling. Two or more things are orthogonal if changes in one doesn't affect the others. Good orthogonality can be a backend and frontend. You should be able to change the database without changing the user interface, and vise versa. Non-orthogonal sytems are much harder to change and control. Orthogonality can be used by our design. Developers already put this into practice but use terms like "modular", "component-based", and "layered". Systems should be composed of a set of modules that you can easily change independently. Be careful about using libraries and toolkits, make sure they don't change any processes of current code. Write shy code. Avoid global data. Get in the habit of being constantly critical of your code and always be improving it - this process is called refactoring. If orthogonality and DRY principles are followed in tandem, you will find that the systems you develop are more flexible, more understandable, and more easier to test and maintain. If you find that when you change a single piece of code, and you notice other things start breaking as a result, remember the system is not orthogonal - it is time to refactor.

### Topic 11. Reversibility
Nothing is forever. If you rely heavily on a fact you can almost guarantee it will change. Mistakes lie where we assume any decisions are set in stone, instead imagine they are words written in the sand at the beach. There are no concrete decisions. You should be able to swap out databases with ease, or easily adjust your server to run a mobile app rather than a web app. Forgo following fads. Nobody knows what the future holds, especially us in the tech world.

### Topic 12. Tracer Bullets
Tracer bullets are loaded in intervals among regular ammunition. If the tracers are hitting the targets, then so is their regular bullets. Like the gunners, we're trying to hit targets in the dark. We face a large number of unknowns. We can guarantee the envorinment in which we're working in to change before we're done. Pragmatic programmers should use code that glows in the dark. Look for important requirements, the ones that define the system. Prioritize these requirements to focus in on. Tracer development is an incremental approach, a project is never finished. Users get to see something working early. If you communicate correctly they will know they are seeing something immature, something that is just starting and they will be excited to see progress. This also allows them to contribute and help along the way. This is in contrast to "big bang" programming. You have better feel for progress. Each iteration feels like a large step forward. Sometimes our tracer bullets don't hit the target, but that's ok. That's the point. Use the tracers to take better aim at it next time, and because you've written easy to change code, refactoring won't be catastrophic. You might use a pre-built UI, get it approved, and then delete everything to integrate the required business rules in your code. That prebuilt UI is a tracer bullet.

### Topic 13. Prototypes and Post-it Notes
Prototypes speed up production. We make prototypes to analyze strengths and weaknesses. We usually think of prototypes created from code, but there are many different prototypes we can make depending on the project. Prototypes will work in a very limited sense to demonstrate or test what the goal is if you were to build it. Ask yourself if you're building a prototype or if you're building the project, if you're building the prototype begin building using the tracer bullets method. When we have a prototype we can ask questions to see if it stacks up to our requirements. Make sure others know that a prototype is disposable code. If you believe the thinking process to the use of your prototype will be confused, build with the tracer bullet method rather than building a prototype.

### Topic 14. Domain Languages
Not going to lie, this topic went right over my head. Hopefully next time I read this book I'll have something to note here.

### Topic 15. Estimating
Estimate to avoid surprises. All answers are estimates, but some are more accurate than others. Are they looking for accuracy, or a rough ball park answer? If you feel your work can get done in 2 weeks, quote it in days. 3-6 weeks, quote it in weeks. 8-20 weeks, quote it in months. If you think it will take more than 20 weeks, think hard before giving an estimate. All estimates are based on models of the problem. A good way to know a good estimate, ask someone who has already done it. Understand what is being asked. "Assuming there is gas in the tank and no traffic on the way, I should be there in 20 minutes." Record your estimates and see how close you were. Often you'll find that your estimates were pretty good, and you'll begin to expect this. If you're wrong take some time to think about what you forgot about or what went wrong, and use it to improve on your future estimates. Give a range of scenarios, a best case, a likely scenario, and a worst case scenario. 

## Chapter 3: The Basic Tools
Every worker starts their journey with a good set of basic tools. Then each worker learns more. Each tool needs handled or worn a certain way. These tools have become extensions to the worker's hands. As you have more experience and knowledge you will slowly add to your set of tools. Always be looking for better ways to do things. This chapter is about exploring our basic tools and finding better ways to do things.

### Topic 16. The Power of Plain Text
Plain text is made up of principle characters that conveys information. Could be a shopping list, or anything else. Keep knowledge in plain text. Human readable is different than human understandable. Just about everything operates on plain text.

### Topic 17. Shell Games
The workbench of a programmer is the shell terminal. If you do all your work on GUIs you miss a lot of power in your environment. You can't set automations or macros for things you do regularly. GUIs are limited by the people that made them, and often you need to go beyond the limits. Gain familiarity with the shell. It might look daunting to begin with but spend some time on it and things will start falling into place. We need to customize our shell. Adding aliases for things that we forget. Add command finishing functionality. We spend a lot of time in our shells so make it our home.

### Topic 18. Power Editing
We need to achieve editor fluency. You might gain a whole week a year by optimizing how you edit code. Comment and uncomment lines of code with a single command. Search for strings and regexp. Can we do all of this and more with a mouse or trackpad? If we can't maybe its time to switch editors. Everytime we find ourselves doing something repetitive, think "there must be a better way." Then find the better way and commit it to memory. Dig into your editor's extension language if you can't find the fix. Turn off auto delete, but instead figure out how to select a portion of text and delete it with only your keyboard. Spend a week not touching your mouse and if there's something you can't do, now is your time to learn it. You'll take a productivity hit for a while, but once you're fluent in your editor you will see you are far more efficient than previously.

### Topic 19. Version Control
Those that can't remember the past are condemned to repeat it. Version control systems are giant undo keys. Shared directories are not version control. Version control systems keep track of every minute change in your code. You will be able to see the difference between last week and this week, who changed it, and how many lines of code were added and deleted. Always use version control. Even if its a throw-away project. Maybe you aren't writing source code, still use version control. The text of this book was written with a version control system. Branches are a huge benefit of a version control system. Branches are like small clones of the project, that doesn't interfere or make changes to your team's branches or the main branch until you merge it to the main branch. Many teams have a deployment automation that when changes are merged to the main branch, it automatically runs the tests, validates the source code, and deploys it live. Seems scary, but we have version control - we can just roll it back if it fails. Do you know all of the commands to do these things? Learn these now before it's an emergency.

### Topic 20. Debugging
The word bug has been used to describe an object of terror since the 14th century. The inventor of Cobal is credited to find the first computer bug - literally. A moth had found its way into the computer. Computer systems are limited to what we tell them to do, not what we want them to do. Embrace the fact that debugging is just problem solving. Instead of blaming the person that caused the bug, work on the problem. Fix the problem, not the blame. Turn off your ego when debugging. Don't panic. Step back, and actually think about what would cause the symptoms of the bug. Don't waste a single neuron on the thought of "that can't happen", because clearly it can - and has. Resist the urge to fix just the symptoms you see. It may involve a number of other related things. Find the root cause of the problem, not this particular appearance of it. Make sure we write code cleanly - without warnings. Set your linter to the highest settings. Fail a test before fixing code. Look at the problem - is it a crash? Read the error message. What if it's not a crash, what if it's just a bad result? Sometimes the problem is obvious. More often, we have to look deeper to find the true problem. Read the call stack. "Binary chop" is a method or algorithm that allows you to find the data you need in a very efficient way. You cut the data in half, check the highest number in first half and if smaller than our search value, take the second half. Continue cutting the data in half until you find the value you're looking for. We can apply this algorithm to debugging the call stack. Cut the callstack down the middle and see if the bug manifests itself there, if it is you know to focus on the frames before. If not you know to focus on the frames after. At most this will take you 6 attempts to find the bug. Print statements are effective at debugging where debuggers can't. These are called tracer statements. A very simple but effective technique to debug is rubber ducking... Explain every step of the code out loud to a person or thing. By having to verbalize each step, you might realize something that you would've taken for granted going through your code alone. The amount of disbelief when a bug occurs is the amount of trust you put into the code you've written.

### Topic 21. Text Manipulation
Pragmatic programmers manipulate text the same way woodworkers manipulate wood. We need to handle transformations that can't be handled by the basic tools we already know and use. Learn a text manipulation language - like Python. Use these languages to automate things. If we take the advice to keep things in plain text, using these text manipulation languages to write scripts will bring a whole host of benefits. Automations used to index this book and upload sample PDFs are keen examples of what this can do.

### Topic 22. Engineering Daybooks
A daybook is a journal in which they recorded everything they did. Stuff they learned, ideas, sketches. When the book got full, they would write the date and stick it on the shelf. Jot down what you're working on. While you're debugging write down stack calls. When needing to remember to come back to something, write it down. It gives you a place to store ideas that isn't immediately relevant to the task at hand. It acts as a kind of rubber duck, for us to explain something we're working on and see the issue. We can use daybooks as a memory to look back on as well.